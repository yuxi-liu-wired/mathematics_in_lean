import MIL.Common
import Mathlib.Topology.Instances.Real

open Set Filter Topology

-- The principal filter generated by a set `s` is the filter of sets containing `s`.
def principal {α : Type*} (s : Set α) : Filter α
    where
  sets := { t | s ⊆ t }
  univ_sets := by simp
  sets_of_superset := by apply Subset.trans
  inter_sets := by
    simp
    intro _ _ s'in s''in
    exact ⟨s'in, s''in⟩

example : Filter ℕ :=
  { sets := { s | ∃ a, ∀ b, a ≤ b → b ∈ s }
    univ_sets := by simp
    sets_of_superset := by
      intro x y xin xsuby
      simp at xin
      rcases xin with ⟨a, ha⟩
      simp
      use a
      intro b hab
      have binx : b ∈ x := ha b hab
      exact xsuby binx
    inter_sets := by
      intro x y hx hy
      simp at hx hy
      simp
      rcases hx with ⟨a, ha⟩
      rcases hy with ⟨b, hb⟩
      use max a b
      intro c ablec
      have cinx : c ∈ x := by
        apply ha
        exact le_of_max_le_left ablec
      have ciny : c ∈ y := by
        apply hb
        exact le_of_max_le_right ablec
      exact ⟨cinx, ciny⟩
  }


def Tendsto₁ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :=
  ∀ V ∈ G, f ⁻¹' V ∈ F

-- For filters, F ≤ G is actually G ⊆ F
-- since this preserves the ordering for principal filters.
def Tendsto₂ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :=
  map f F ≤ G

example {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) :
    Tendsto₂ f F G ↔ Tendsto₁ f F G :=
  Iff.rfl

#check (@Filter.map_mono : ∀ {α β} {m : α → β}, Monotone (map m))

#check
  (@Filter.map_map :
    ∀ {α β γ} {f : Filter α} {m : α → β} {m' : β → γ}, map m' (map m f) = map (m' ∘ m) f)

-- Composition of two functional limits
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z}
    (hf : Tendsto₁ f F G) (hg : Tendsto₁ g G H) : Tendsto₁ (g ∘ f) F H := by
  dsimp [Tendsto₁] at *
  intro V VinH
  have gVinG : g ⁻¹' V ∈ G := by
    apply hg
    exact VinH
  have fgVinF : f ⁻¹' (g ⁻¹' V) ∈ F := by
    apply hf
    exact gVinG
  exact fgVinF

example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z}
    (hf : Tendsto₂ f F G) (hg : Tendsto₂ g G H) : Tendsto₂ (g ∘ f) F H := by
  dsimp [Tendsto₂] at *
  rw [← Filter.map_map]
  calc
    map g (map f F) ≤ map g G := by
      apply Filter.map_mono
      exact hf
    _ ≤ H := hg

variable (f : ℝ → ℝ) (x₀ y₀ : ℝ)

-- map : image :: comap : preimage
-- And just like image-preimage, the map-comap pair is a Galois connection,
--     or an adjunction between the poset-categories.
#check comap ((↑) : ℚ → ℝ) (𝓝 x₀)

#check Tendsto (f ∘ (↑)) (comap ((↑) : ℚ → ℝ) (𝓝 x₀)) (𝓝 y₀)

section
variable {α β γ : Type*} (F : Filter α) {m : γ → β} {n : β → α}

#check (comap_comap : comap m (comap n F) = comap (n ∘ m) F)

end

-- The neighborhood filter of (x, y)
-- is made up of sets of type (neighborhood of x) × (neighborhood of y).
example : 𝓝 (x₀, y₀) = 𝓝 x₀ ×ˢ 𝓝 y₀ :=
  nhds_prod_eq

#check le_inf_iff
#check tendsto_fst
#check Tendsto.comp
#check tendsto_fst.comp

example (f : ℕ → ℝ × ℝ) (x₀ y₀ : ℝ) :
    Tendsto f atTop (𝓝 (x₀, y₀)) ↔
      Tendsto (Prod.fst ∘ f) atTop (𝓝 x₀) ∧ Tendsto (Prod.snd ∘ f) atTop (𝓝 y₀) := by
  rw [nhds_prod_eq]
  constructor
  . intro h
    constructor
    . apply Tendsto.comp tendsto_fst h
    . apply Tendsto.comp tendsto_snd h
  . rintro ⟨h₁, h₂⟩
    have : Tendsto (fun x ↦ ((Prod.fst ∘ f) x, (Prod.snd ∘ f) x)) atTop (𝓝 x₀ ×ˢ 𝓝 y₀) := by
      apply Tendsto.prod_mk
      . exact h₁
      . exact h₂
    assumption

example (x₀ : ℝ) : HasBasis (𝓝 x₀) (fun ε : ℝ ↦ 0 < ε) fun ε ↦ Ioo (x₀ - ε) (x₀ + ε) :=
  nhds_basis_Ioo_pos x₀

example (u : ℕ → ℝ) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, u n ∈ Ioo (x₀ - ε) (x₀ + ε) := by
  have atTop_basis : atTop.HasBasis (fun _ : ℕ ↦ True) Ici := atTop_basis
  have real_basis : (𝓝 x₀).HasBasis (fun ε : ℝ ↦ 0 < ε) fun ε ↦ Ioo (x₀ - ε) (x₀ + ε) :=
    nhds_basis_Ioo_pos x₀
  rw [HasBasis.tendsto_iff atTop_basis real_basis]
  simp

example (P Q : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n) :
    ∀ᶠ n in atTop, P n ∧ Q n :=
  hP.and hQ

example (u v : ℕ → ℝ) (h : ∀ᶠ n in atTop, u n = v n) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) :=
  tendsto_congr' h

example (u v : ℕ → ℝ) (h : u =ᶠ[atTop] v) (x₀ : ℝ) :
    Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) :=
  tendsto_congr' h

#check eventually_of_forall
#check Eventually.mono
#check Eventually.and

example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n)
    (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by
  apply (hP.and (hQ.and hR)).mono
  rintro n ⟨h, h', h''⟩
  exact h'' ⟨h, h'⟩

example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n)
    (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by
  filter_upwards [hP, hQ, hR] with n h h' h''
  exact h'' ⟨h, h'⟩

#check mem_closure_iff_clusterPt
#check le_principal_iff
#check neBot_of_le

example (u : ℕ → ℝ) (M : Set ℝ) (x : ℝ) (hux : Tendsto u atTop (𝓝 x))
    (huM : ∀ᶠ n in atTop, u n ∈ M) : x ∈ closure M := by
  rw [mem_closure_iff_clusterPt]
  simp [ClusterPt]
  have h : map u atTop ≤ 𝓝 x ⊓ 𝓟 M := by
    apply le_inf
    . exact hux
    . rw [le_principal_iff]
      exact huM
  apply neBot_of_le h
