import MIL.Common
import Mathlib.Topology.Instances.Real

open Set Filter Topology

-- The principal filter generated by a set `s` is the filter of sets containing `s`.
def principal {Î± : Type*} (s : Set Î±) : Filter Î±
    where
  sets := { t | s âŠ† t }
  univ_sets := by simp
  sets_of_superset := by apply Subset.trans
  inter_sets := by
    simp
    intro _ _ s'in s''in
    exact âŸ¨s'in, s''inâŸ©

example : Filter â„• :=
  { sets := { s | âˆƒ a, âˆ€ b, a â‰¤ b â†’ b âˆˆ s }
    univ_sets := by simp
    sets_of_superset := by
      intro x y xin xsuby
      simp at xin
      rcases xin with âŸ¨a, haâŸ©
      simp
      use a
      intro b hab
      have binx : b âˆˆ x := ha b hab
      exact xsuby binx
    inter_sets := by
      intro x y hx hy
      simp at hx hy
      simp
      rcases hx with âŸ¨a, haâŸ©
      rcases hy with âŸ¨b, hbâŸ©
      use max a b
      intro c ablec
      have cinx : c âˆˆ x := by
        apply ha
        exact le_of_max_le_left ablec
      have ciny : c âˆˆ y := by
        apply hb
        exact le_of_max_le_right ablec
      exact âŸ¨cinx, cinyâŸ©
  }


def Tendstoâ‚ {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :=
  âˆ€ V âˆˆ G, f â»Â¹' V âˆˆ F

-- For filters, F â‰¤ G is actually G âŠ† F
-- since this preserves the ordering for principal filters.
def Tendstoâ‚‚ {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :=
  map f F â‰¤ G

example {X Y : Type*} (f : X â†’ Y) (F : Filter X) (G : Filter Y) :
    Tendstoâ‚‚ f F G â†” Tendstoâ‚ f F G :=
  Iff.rfl

#check (@Filter.map_mono : âˆ€ {Î± Î²} {m : Î± â†’ Î²}, Monotone (map m))

#check
  (@Filter.map_map :
    âˆ€ {Î± Î² Î³} {f : Filter Î±} {m : Î± â†’ Î²} {m' : Î² â†’ Î³}, map m' (map m f) = map (m' âˆ˜ m) f)

-- Composition of two functional limits
example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X â†’ Y} {g : Y â†’ Z}
    (hf : Tendstoâ‚ f F G) (hg : Tendstoâ‚ g G H) : Tendstoâ‚ (g âˆ˜ f) F H := by
  dsimp [Tendstoâ‚] at *
  intro V VinH
  have gVinG : g â»Â¹' V âˆˆ G := by
    apply hg
    exact VinH
  have fgVinF : f â»Â¹' (g â»Â¹' V) âˆˆ F := by
    apply hf
    exact gVinG
  exact fgVinF

example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X â†’ Y} {g : Y â†’ Z}
    (hf : Tendstoâ‚‚ f F G) (hg : Tendstoâ‚‚ g G H) : Tendstoâ‚‚ (g âˆ˜ f) F H := by
  dsimp [Tendstoâ‚‚] at *
  rw [â† Filter.map_map]
  calc
    map g (map f F) â‰¤ map g G := by
      apply Filter.map_mono
      exact hf
    _ â‰¤ H := hg

variable (f : â„ â†’ â„) (xâ‚€ yâ‚€ : â„)

-- map : image :: comap : preimage
-- And just like image-preimage, the map-comap pair is a Galois connection,
--     or an adjunction between the poset-categories.
#check comap ((â†‘) : â„š â†’ â„) (ğ“ xâ‚€)

#check Tendsto (f âˆ˜ (â†‘)) (comap ((â†‘) : â„š â†’ â„) (ğ“ xâ‚€)) (ğ“ yâ‚€)

section
variable {Î± Î² Î³ : Type*} (F : Filter Î±) {m : Î³ â†’ Î²} {n : Î² â†’ Î±}

#check (comap_comap : comap m (comap n F) = comap (n âˆ˜ m) F)

end

-- The neighborhood filter of (x, y)
-- is made up of sets of type (neighborhood of x) Ã— (neighborhood of y).
example : ğ“ (xâ‚€, yâ‚€) = ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€ :=
  nhds_prod_eq

#check le_inf_iff
#check tendsto_fst
#check Tendsto.comp
#check tendsto_fst.comp

example (f : â„• â†’ â„ Ã— â„) (xâ‚€ yâ‚€ : â„) :
    Tendsto f atTop (ğ“ (xâ‚€, yâ‚€)) â†”
      Tendsto (Prod.fst âˆ˜ f) atTop (ğ“ xâ‚€) âˆ§ Tendsto (Prod.snd âˆ˜ f) atTop (ğ“ yâ‚€) := by
  rw [nhds_prod_eq]
  constructor
  . intro h
    constructor
    . apply Tendsto.comp tendsto_fst h
    . apply Tendsto.comp tendsto_snd h
  . rintro âŸ¨hâ‚, hâ‚‚âŸ©
    have : Tendsto (fun x â†¦ ((Prod.fst âˆ˜ f) x, (Prod.snd âˆ˜ f) x)) atTop (ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€) := by
      apply Tendsto.prod_mk
      . exact hâ‚
      . exact hâ‚‚
    assumption

example (xâ‚€ : â„) : HasBasis (ğ“ xâ‚€) (fun Îµ : â„ â†¦ 0 < Îµ) fun Îµ â†¦ Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) :=
  nhds_basis_Ioo_pos xâ‚€

example (u : â„• â†’ â„) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, u n âˆˆ Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) := by
  have atTop_basis : atTop.HasBasis (fun _ : â„• â†¦ True) Ici := atTop_basis
  have real_basis : (ğ“ xâ‚€).HasBasis (fun Îµ : â„ â†¦ 0 < Îµ) fun Îµ â†¦ Ioo (xâ‚€ - Îµ) (xâ‚€ + Îµ) :=
    nhds_basis_Ioo_pos xâ‚€
  rw [HasBasis.tendsto_iff atTop_basis real_basis]
  simp

example (P Q : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n) :
    âˆ€á¶  n in atTop, P n âˆ§ Q n :=
  hP.and hQ

example (u v : â„• â†’ â„) (h : âˆ€á¶  n in atTop, u n = v n) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” Tendsto v atTop (ğ“ xâ‚€) :=
  tendsto_congr' h

example (u v : â„• â†’ â„) (h : u =á¶ [atTop] v) (xâ‚€ : â„) :
    Tendsto u atTop (ğ“ xâ‚€) â†” Tendsto v atTop (ğ“ xâ‚€) :=
  tendsto_congr' h

#check eventually_of_forall
#check Eventually.mono
#check Eventually.and

example (P Q R : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n)
    (hR : âˆ€á¶  n in atTop, P n âˆ§ Q n â†’ R n) : âˆ€á¶  n in atTop, R n := by
  apply (hP.and (hQ.and hR)).mono
  rintro n âŸ¨h, h', h''âŸ©
  exact h'' âŸ¨h, h'âŸ©

example (P Q R : â„• â†’ Prop) (hP : âˆ€á¶  n in atTop, P n) (hQ : âˆ€á¶  n in atTop, Q n)
    (hR : âˆ€á¶  n in atTop, P n âˆ§ Q n â†’ R n) : âˆ€á¶  n in atTop, R n := by
  filter_upwards [hP, hQ, hR] with n h h' h''
  exact h'' âŸ¨h, h'âŸ©

#check mem_closure_iff_clusterPt
#check le_principal_iff
#check neBot_of_le

example (u : â„• â†’ â„) (M : Set â„) (x : â„) (hux : Tendsto u atTop (ğ“ x))
    (huM : âˆ€á¶  n in atTop, u n âˆˆ M) : x âˆˆ closure M := by
  rw [mem_closure_iff_clusterPt]
  simp [ClusterPt]
  have h : map u atTop â‰¤ ğ“ x âŠ“ ğ“Ÿ M := by
    apply le_inf
    . exact hux
    . rw [le_principal_iff]
      exact huM
  apply neBot_of_le h
